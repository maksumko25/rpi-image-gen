#!/usr/bin/env bash
set -euo pipefail

# ----------- CLI -----------
IMG=""
OUT=""
RECOMPRESS="n"
declare -a SEARCH=()     # -S PATH (repeatable)
PROFILE_ID=""            # -p ID   (profile file listing layer names)
LAYER_CSV=""             # --layers id1,id2,...
declare -a VARS=()       # --var KEY=VALUE (repeatable)
RSYNC_OPTS="-aHAX --numeric-ids --inplace"
RSYNC_OPTS_BOOT="-rlt --inplace --no-perms --no-owner --no-group"

usage() {
  cat <<'EOF'
Usage:
  rpi-image-gen update-image -i <image.(img|img.xz)> [--out <out.img>] \
    [-S <search_dir> ...] [-p <profile_id> | --layers <id1,id2,...>] \
    [--var KEY=VALUE ...] [--xz]

Where:
  -i, --image     Source image path (.img or .img.xz)
  --out           Optional output .img path (default: edit a temp copy if input is .xz; otherwise edit in-place)
  -S              Add a search path (may be repeated). Order = precedence.
                  Typical: -S ./ext -S .
  -p              Profile ID: a text file under <search>/profile/<ID> listing layer names (one per line; '#' comments ok)
  --layers        Comma-separated layer ids (alternative to -p)
  --var           Provide variables for scripts/templates (become IGconf_<KEY> env vars). Repeatable.
  --xz            Recompress OUT/.img to .img.xz on success

Layer content (any optional subset per layer):
  <search>/layer/<id>/update/bootfs-overlay/   -> copied onto boot partition
  <search>/layer/<id>/update/rootfs-overlay/   -> copied onto rootfs partition
  <search>/layer/<id>/update/customize.d/*.sh  -> executed on host with args: <ROOTFS> <BOOTFS>
                                                   (Your script may chroot to <ROOTFS> if needed)

Examples:
  # Replace cmdline.txt using a layer "cmdline-my" found in ./ext/layer/cmdline-my/update/bootfs-overlay/cmdline.txt
  sudo rpi-image-gen update-image -i ./deb12.img \
       -S ./ext --layers cmdline-my

  # Same, but image is .xz and you want .xz output again:
  sudo rpi-image-gen update-image -i ./deb12.img.xz \
       -S ./ext --layers cmdline-my --xz

  # Apply multiple layers from a profile file ./ext/profile/wifi-and-cmdline:
  sudo rpi-image-gen update-image -i ./deb12.img -S ./ext -p wifi-and-cmdline \
       --var network_ssid=MySSID --var network_psk=SuperSecret
EOF
}

# Parse
while (( $# )); do
  case "$1" in
    -i|--image) IMG="$2"; shift 2;;
    --out) OUT="$2"; shift 2;;
    -S) SEARCH+=("$(readlink -m "$2")"); shift 2;;
    -p) PROFILE_ID="$2"; shift 2;;
    --layers) LAYER_CSV="$2"; shift 2;;
    --var) VARS+=("$2"); shift 2;;
    --xz) RECOMPRESS="y"; shift;;
    -h|--help) usage; exit 0;;
    *) echo "Unknown option: $1" >&2; usage; exit 2;;
  esac
done

[[ -n "$IMG" ]] || { echo "Missing --image"; usage; exit 2; }

# Defaults: if no -S given, search current repo root then /usr/share install
if [[ ${#SEARCH[@]} -eq 0 ]]; then
  # derive IGTOP similar to main script
  this_dir=$(dirname "$(readlink -e "$0")")
  IGTOP="$(cd "$this_dir/.." && pwd -P)"
  SEARCH+=("$IGTOP" "/usr/share/rpi-image-gen")
fi

# Collect layer ids
declare -a LAYERS=()
if [[ -n "$PROFILE_ID" ]]; then
  found=""
  for S in "${SEARCH[@]}"; do
    f="$S/profile/$PROFILE_ID"
    if [[ -f "$f" ]]; then found="$f"; break; fi
  done
  [[ -n "$found" ]] || { echo "Profile '$PROFILE_ID' not found under: ${SEARCH[*]}"; exit 2; }
  while IFS= read -r line || [[ -n "$line" ]]; do
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    LAYERS+=("$line")
  done <"$found"
fi
if [[ -n "$LAYER_CSV" ]]; then
  IFS=',' read -r -a tmp <<<"$LAYER_CSV"
  LAYERS+=("${tmp[@]}")
fi
# Dedup while preserving order
declare -A seen=()
declare -a LAYERS_U=()
for L in "${LAYERS[@]}"; do
  [[ -n "${seen[$L]:-}" ]] || { LAYERS_U+=("$L"); seen["$L"]=1; }
done
LAYERS=("${LAYERS_U[@]}")

if [[ ${#LAYERS[@]} -eq 0 ]]; then
  echo "No layers provided (use -p <profile> or --layers id1,id2)"; usage; exit 2
fi

# Export variables as IGconf_* for hooks/templates
for kv in "${VARS[@]}"; do
  k="${kv%%=*}"; v="${kv#*=}"
  export "IGconf_${k}=$v"
done

# ----------- Work dirs & cleanup -----------
IMG="$(readlink -e "$IMG")"
WORKDIR="$(mktemp -d)"
BOOT_MNT="$WORKDIR/boot"; ROOT_MNT="$WORKDIR/root"
mkdir -p "$BOOT_MNT" "$ROOT_MNT"

cleanup() {
  set +e
  mountpoint -q "$BOOT_MNT" && sudo umount "$BOOT_MNT"
  mountpoint -q "$ROOT_MNT" && sudo umount "$ROOT_MNT"
  [[ -n "${LOOPDEV:-}" ]] && sudo losetup -d "$LOOPDEV" 2>/dev/null
  rm -rf "$WORKDIR"
}
trap cleanup EXIT INT TERM

# Decompress if needed
SRC_IS_XZ="n"
if [[ "$IMG" =~ \.xz$ ]]; then
  SRC_IS_XZ="y"
  DECOMP_IMG="$WORKDIR/image.img"
  echo "Decompressing $IMG ..."
  xz -dc -- "$IMG" > "$DECOMP_IMG"
  IMG="$DECOMP_IMG"
fi

# Copy if --out specified
if [[ -n "${OUT:-}" ]]; then
  cp --reflink=auto --sparse=always "$IMG" "$OUT"
  IMG="$(readlink -m "$OUT")"
fi

# Map & mount
echo "Mapping loop device..."
LOOPDEV="$(sudo losetup -Pf --show "$IMG")"
sudo mount "${LOOPDEV}p1" "$BOOT_MNT"

# Detect FS type
FSTYPE=$(lsblk -no FSTYPE "${LOOPDEV}p1" | head -n1 || true)
if [[ "$FSTYPE" == "vfat" || "$FSTYPE" == "exfat" || "$FSTYPE" == "fat32" || "$FSTYPE" == "fat" ]]; then
  # remount with root ownership mapping to avoid odd UIDs
  sudo umount "$BOOT_MNT"
  sudo mount -t vfat -o uid=0,gid=0,umask=077 "${LOOPDEV}p1" "$BOOT_MNT"
fi

# Rootfs (optional)
sudo mount "${LOOPDEV}p2" "$ROOT_MNT" 2>/dev/null || true

# ----------- Helpers -----------
find_layer_dir() {
  local id="$1"
  for S in "${SEARCH[@]}"; do
    [[ -d "$S/layer/$id" ]] && { echo "$S/layer/$id"; return 0; }
  done
  return 1
}

apply_overlay() {
  local src="$1" dst="$2"
  [[ -d "$src" ]] || return 0
  local opts="$RSYNC_OPTS_ROOT"
  if [[ "$dst" == "$BOOT_MNT" ]]; then
    opts="$RSYNC_OPTS_BOOT"
  fi
  echo "Overlay -> $dst : $src"
  sudo rsync $opts "$src"/ "$dst"/
}

run_customize() {
  local dir="$1"
  [[ -d "$dir" ]] || return 0
  echo "Running customize scripts in: $dir"
  # Provide root/boot paths and IGconf_* env to scripts
  for sh in $(find "$dir" -type f -name '*.sh' | sort); do
    echo " -> $sh"
    chmod +x "$sh" 2>/dev/null || true
    IGconf_rootfs="$ROOT_MNT" IGconf_bootfs="$BOOT_MNT" "$sh" "$ROOT_MNT" "$BOOT_MNT"
  done
}

# ----------- Apply layers -----------
for L in "${LAYERS[@]}"; do
  LDIR="$(find_layer_dir "$L")" || { echo "Layer '$L' not found in: ${SEARCH[*]}"; exit 2; }
  echo "== Layer: $L  @ $LDIR =="

  # Boot overlay
  apply_overlay "$LDIR/update/bootfs-overlay" "$BOOT_MNT"

  # Rootfs overlay
  apply_overlay "$LDIR/update/rootfs-overlay" "$ROOT_MNT"

  # Customize scripts
  run_customize "$LDIR/update/customize.d"
done

sync

# ----------- Recompress if asked -----------
if [[ "${RECOMPRESS}" == "y" ]]; then
  OUTIMG="$IMG"
  [[ -n "${OUT:-}" ]] && OUTIMG="$OUT"
  echo "Compressing to ${OUTIMG}.xz ..."
  xz -T0 -f "$OUTIMG"
fi

echo "update-image: OK"
